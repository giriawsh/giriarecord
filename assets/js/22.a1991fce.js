(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{372:function(t,e,s){"use strict";s.r(e);var v=s(42),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"属性的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属性的特性"}},[t._v("#")]),t._v(" 属性的特性")]),t._v(" "),s("p",[t._v("除了名字和值之外，属性还包含一些表示它们"),s("strong",[t._v("可写、可枚举、可配置")]),t._v("的特性。")]),t._v(" "),s("p",[t._v("在ES3中无法设置这些特性，所有通过ES3程序创建的属性"),s("u",[t._v("都是可写、可枚举、可配置的，且无法对这些特性做修改")]),t._v("。")]),t._v(" "),s("p",[t._v("ES5中可以利用API查询和设置这些属性，具有非常重要的意义：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110143213.png",alt:"image-20201110143206062"}})]),t._v(" "),s("p",[t._v("我们可以把存储器属性的getter和setter方法看成是属性的特性，按照这个逻辑，我们也可以把数据属性的值看做是属性的特性。")]),t._v(" "),s("p",[t._v("因此可以认为一个"),s("strong",[t._v("属性")]),t._v("包含"),s("strong",[t._v("一个名字和四个特性")]),t._v("。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("数据属性的4个特性：值value、可写性writable、可枚举型enumerable、可配置性configurable")])]),t._v(" "),s("li",[s("p",[t._v("存取器属性的4个特性：读取get、写入set、可枚举型enumerable、可配置性configurable")])])]),t._v(" "),s("p",[t._v("存取器属性不具有值特性和可写性，它们的可写性是由setter方法存在与否决定的。")]),t._v(" "),s("p",[t._v("为了实现属性特性的查询和设置操作，ES5中定义了名为"),s("strong",[t._v("属性描述符")]),t._v("的"),s("strong",[t._v("对象")]),t._v("。")]),t._v(" "),s("p",[t._v("这个对象代表那四个特性，描述符对象的属性和它们所描述的属性特性是同名的。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("数据属性的描述符对象的属性：value、writable、enumerable、configurable")])]),t._v(" "),s("li",[s("p",[t._v("存取器属性的描述符对象的属性：get、set、enumerable、configurable")])])]),t._v(" "),s("p",[t._v("其中writable、enumerable、configurable都是布尔值，get属性和set属性是函数值。")]),t._v(" "),s("h3",{attrs:{id:"object-getownpropertydescriptor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-getownpropertydescriptor"}},[t._v("#")]),t._v(" "),s("code",[t._v("Object.getOwnPropertyDescriptor()")])]),t._v(" "),s("p",[t._v("通过调用"),s("code",[t._v("Object.getOwnPropertyDescriptor()")]),t._v("可以获得"),s("strong",[t._v("某个特定属性的属性描述符")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110144117.png",alt:"image-20201110144117171"}})]),t._v(" "),s("p",[s("code",[t._v("Object.getOwnPropertyDescriptor()")]),t._v("只能得到"),s("strong",[t._v("自有属性")]),t._v("的描述符。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("获得继承属性的特性")]),t._v(" "),s("p",[t._v("如果想要获得继承属性的特性，需要遍历原型链（使用"),s("code",[t._v("Object.getPrototypeOf()")]),t._v("）.")])]),t._v(" "),s("h3",{attrs:{id:"object-defineproperty"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[t._v("#")]),t._v(" "),s("code",[t._v("Object.defineProperty")])]),t._v(" "),s("p",[s("strong",[t._v("设置属性的特性，想让新建属性具有某种特性")]),t._v("。")]),t._v(" "),s("p",[t._v("调用"),s("code",[t._v("Object.defineProperty()")]),t._v("，传入要修改的"),s("u",[t._v("对象")]),t._v("、要创建或修改的"),s("u",[t._v("属性的名称")]),t._v("以及"),s("u",[t._v("属性描述符对象")]),t._v("：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110144716.png",alt:"image-20201110144716323"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110144725.png",alt:"image-20201110144725707"}})]),t._v(" "),s("p",[t._v("传入"),s("code",[t._v("Object.defineProperty()")]),t._v("的属性描述符对象"),s("strong",[t._v("不必包含所有四个特性")]),t._v("。")]),t._v(" "),s("p",[t._v("对于新创建的属性来说，"),s("strong",[t._v("默认的特性值是false或undefined")]),t._v("；对于修改的已有属性来说，默认的特性值没有做任何修改。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意！！")]),t._v(" "),s("p",[t._v("这个方法要么修改已有属性、要么新建，但"),s("strong",[t._v("不能修改继承属性")])])]),t._v(" "),s("h3",{attrs:{id:"object-defineproperties"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperties"}},[t._v("#")]),t._v(" "),s("code",[t._v("Object.defineProperties()")])]),t._v(" "),s("p",[t._v("如果要同时修改或创建多个属性，需要使用"),s("code",[t._v("Object.defineProperties()")]),t._v("。")]),t._v(" "),s("p",[t._v("第一个参数是要修改的对象，第二个参数是一个映射表，包含要新建或修改的属性的名称+它们的属性描述符。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110170304.png",alt:"image-20201110170304821"}})]),t._v(" "),s("p",[t._v("这段代码给一个空对象，添加两个数据属性和一个只读存取器属性。最终返回修改后的对象(和"),s("code",[t._v("Object.defineProperty()")]),t._v("一样)")]),t._v(" "),s("h4",{attrs:{id:"使用规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用规则"}},[t._v("#")]),t._v(" 使用规则")]),t._v(" "),s("p",[t._v("对于那些不允许创建或修改的属性来说，如果使用"),s("code",[t._v("Object.defineProperty()")]),t._v("和"),s("code",[t._v("Object.defineProperties()")]),t._v("用来新建或修改，就会"),s("u",[t._v("抛出类型错误异常")]),t._v("。比如：给一个不可扩展的对象新增属性。")]),t._v(" "),s("p",[t._v("可写性——控制对值特性的修改；")]),t._v(" "),s("p",[t._v("可配置性——控制着对其他特性（包括属性是否可以删除）的修改；")]),t._v(" "),s("p",[t._v("但规则远不止这么简单，例如：")]),t._v(" "),s("p",[t._v("属性时可配置的，则可以修改不可写属性的值；属性时不可配置的，仍然可以将可写属性修改为不可写属性。")]),t._v(" "),s("p",[t._v("以下是完整规则，任何对"),s("code",[t._v("Object.defineProperty()")]),t._v("或"),s("code",[t._v("Object.defineProperties()")]),t._v("违反规则的使用都会抛出错误异常")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110170728.png",alt:"image-20201110170728303"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110170743.png",alt:"image-20201110170743737"}})]),t._v(" "),s("p",[t._v("在之前我们实现了extend()函数，把一个对象的属性复制到另一个对象中：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110170929.png",alt:"image-20201109204958052"}})]),t._v(" "),s("p",[t._v("但是这个函数只是简单地复制属性名和值，它有以下缺点：")]),t._v(" "),s("ol",[s("li",[t._v("没有复制属性的特性")]),t._v(" "),s("li",[t._v("没有复制存取器属性的getter和setter方法，只是将它们简单地转换为静态的数据属性。")])]),t._v(" "),s("p",[t._v("以下改进extend()函数中，使用"),s("code",[t._v("Object.defineProperty()")]),t._v("和"),s("code",[t._v("Object.getOwnPropertyDescriptor")]),t._v("对属性的所有特性进行复制。")]),t._v(" "),s("p",[t._v("新的extend()作为不可枚举属性添加到Object.prototype中，因此它是Object上定义的"),s("strong",[t._v("新方法")]),t._v("，而不是一个独立的函数。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201110171211.png",alt:"image-20201110171211309"}})]),t._v(" "),s("p",[t._v("函数中的this指向调用这个方法的对象。")]),t._v(" "),s("p",[t._v("当然用这种方式，只能保证对**自有属性（包括不可枚举属性）**进行复制。")]),t._v(" "),s("h3",{attrs:{id:"getter和setter的老式api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getter和setter的老式api"}},[t._v("#")]),t._v(" getter和setter的老式API")]),t._v(" "),s("p",[t._v("可以通过对象直接量语法给新对象定义存取器属性，但"),s("strong",[t._v("不能查询")]),t._v("属性的getter或setter方法或给已有的对象添加新的存取器属性。")]),t._v(" "),s("p",[t._v("在ES5中，可以通过"),s("code",[t._v("Object.getOwnpropertyDescriptor()")]),t._v("和"),s("code",[t._v("Object.defineProperty()")]),t._v("来完成这些工作。")]),t._v(" "),s("p",[t._v("在ES5之前，大多数JS的实现已经可以支持对象直接量语法中的get和set写法。这些实现提供了老式API用来查询和设置getter和setter。")]),t._v(" "),s("p",[t._v("这些API由4个方法组成，所有对象都拥有这些方法：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("__lookupGetter")]),t._v("和"),s("code",[t._v("__lookupSetter__")]),t._v("用以返回一个命名属性的getter和setter方法。")]),t._v(" "),s("li",[s("code",[t._v("__defineGetter__()")]),t._v("和"),s("code",[t._v("__defineSetter__()")]),t._v("用以定义getter和setter，这两个函数的第一个参数是属性名字，第二个参数是getter和setter方法。")])]),t._v(" "),s("p",[t._v("这四个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。")]),t._v(" "),s("h2",{attrs:{id:"对象的三个属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象的三个属性"}},[t._v("#")]),t._v(" 对象的三个属性")]),t._v(" "),s("p",[t._v("每一个对象都有与之相关的"),s("strong",[t._v("原型、类、可扩展性")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"原型属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型属性"}},[t._v("#")]),t._v(" 原型属性")]),t._v(" "),s("p",[t._v("对象的原型属性时"),s("u",[t._v("用来继承属性")]),t._v("的。我们经常把“o的原型属性”直接叫做“o的原型”。")]),t._v(" "),s("p",[s("strong",[t._v("原型属性")]),t._v("，是在实例对象创建之初就设置好的：")]),t._v(" "),s("ul",[s("li",[t._v("通过对象直接量创建的对象使用Object.prototype作为它们的原型")]),t._v(" "),s("li",[t._v("通过new创建的对象使用构造函数的prototype作为它们的原型")]),t._v(" "),s("li",[t._v("通过Object.create()创建的对象使用第一个参数（可以是null）作为它们的原型")])]),t._v(" "),s("p",[t._v("在ES5中，将对象作为参数传入"),s("code",[t._v("Object.getPrototypeOf()")]),t._v("可以查询它的原型。")]),t._v(" "),s("p",[t._v("在ES3中没有与之等价的函数，但经常使用表达式"),s("code",[t._v("o.constructor.prototype")]),t._v("来检测一个对象的原型：")]),t._v(" "),s("ul",[s("li",[t._v("通过new表达式创建的对象，通常继承一个constructor属性，这个属性"),s("u",[t._v("指代创建这个对象的构造函数")])]),t._v(" "),s("li",[t._v("通过对象直接量或Object.create()创建的对象包含一个名为constructor的属性，这个属性"),s("u",[t._v("指代Object()构造函数")])])]),t._v(" "),s("p",[t._v("因此"),s("strong",[t._v("constructor.prototype才是对象直接量的真正的原型")]),t._v("。但对于通过Object.create()创建的对象则往往不是这样。")]),t._v(" "),s("p",[t._v("要想检测一个对象是否是另一个对象的原型（或处于原型链中），需要使用"),s("code",[t._v("isPrototypeOf()")]),t._v("方法。")]),t._v(" "),s("p",[t._v("通过"),s("code",[t._v("p.isPrototypeOf(o)")]),t._v("来检测p是否是o的原型：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111171829.png",alt:"image-20201111171822196"}})]),t._v(" "),s("p",[t._v("需要注意的是，isPrototypeOf()函数实现的功能和instanceof运算符非常类似。（对象 instanceof 类/函数）")]),t._v(" "),s("h4",{attrs:{id:"proto"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proto"}},[t._v("#")]),t._v(" "),s("code",[t._v("__proto__")])]),t._v(" "),s("p",[t._v("Mozilla实现的JS对外暴露了一个专门命名为"),s("code",[t._v("__proto__")]),t._v("的属性，用以查询/设置对象的原型。")]),t._v(" "),s("p",[t._v("但不推荐使用。ES5实现了且依然支持，但对修改不可扩展对象的原型做了限制。")]),t._v(" "),s("h3",{attrs:{id:"类属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类属性"}},[t._v("#")]),t._v(" 类属性")]),t._v(" "),s("p",[t._v("对象的"),s("strong",[t._v("类属性")]),t._v("是一个字符串，用以表示对象的类型信息。")]),t._v(" "),s("p",[t._v("ES3和ES5都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。")]),t._v(" "),s("p",[t._v("默认的"),s("strong",[t._v("toString()方法")]),t._v("（继承自Object.prototype）返回了这种格式的字符串：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("object classname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("因此想要获得对象的类，就可以用toString()方法，然后提取已返回字符串的第八个到倒数第二个位置之间的字符（上面的classname部分）。")]),t._v(" "),s("p",[t._v("需要注意的是：很多对象继承的toString()方法重写了，为了能调用正确的版本，必须"),s("strong",[t._v("间接地调用"),s("code",[t._v("Function.call()")]),t._v("方法。")])]),t._v(" "),s("p",[t._v("下面的classof()函数可以返回传递给它的任意对象的类：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111172321.png",alt:"image-20201111172321552"}})]),t._v(" "),s("p",[t._v("classof()函数可以传入任何类型的参数。")]),t._v(" "),s("p",[t._v("数字、字符串、布尔值可以直接调用toString()方法，就和对象调用toString()方法一样，并且这个函数包含了对null和undefined的特殊处理（ES5中不需要对这些特殊情况做处理）。")]),t._v(" "),s("blockquote",[s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111173415.png",alt:"image-20201111173415737"}})])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("通过内置构造函数（比如Array和Date）创建的对象包含“"),s("strong",[t._v("类属性")]),t._v("”，这和具体JS实现有关。")])]),t._v(" "),s("li",[s("p",[t._v("通过对象直接量和Object.create()创建的对象的类属性是“Object”")])]),t._v(" "),s("li",[s("p",[t._v("那些自定义构造函数创建的对象类属性也是“Object”")])])]),t._v(" "),s("p",[s("u",[t._v("因此对于自定义的类来说，没办法通过类属性来区分对象的类。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111173424.png",alt:"image-20201111173424171"}})]),t._v(" "),s("h3",{attrs:{id:"可扩展性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可扩展性"}},[t._v("#")]),t._v(" 可扩展性")]),t._v(" "),s("p",[t._v("对象的"),s("strong",[t._v("可扩展性")]),t._v("用以表示是否可以给对象添加新属性。")]),t._v(" "),s("p",[t._v("所有"),s("u",[t._v("内置对象")]),t._v("和"),s("u",[t._v("自定义对象")]),t._v("都是显式可扩展的。"),s("u",[t._v("宿主对象")]),t._v("的可扩展性是由JS引擎定义的。")]),t._v(" "),s("p",[t._v("在ES5中，所有内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的。同样宿主对象的可扩展性也是由实现ES5的JS引擎定义的。")]),t._v(" "),s("h4",{attrs:{id:"object-isextensible"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-isextensible"}},[t._v("#")]),t._v(" Object.isExtensible()")]),t._v(" "),s("p",[t._v("ES5中定义了用来查询和设置对象可扩展性的函数。")]),t._v(" "),s("p",[t._v("通过将对象传入"),s("code",[t._v("Object.isExtensible()")]),t._v("来判断该对象是否是可扩展的。")]),t._v(" "),s("h4",{attrs:{id:"object-preventextensions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-preventextensions"}},[t._v("#")]),t._v(" Object.preventExtensions()")]),t._v(" "),s("p",[t._v("如果想将对象转换为不可扩展的，需要调用"),s("code",[t._v("Object.preventExtensions()")]),t._v("，将待转换的对象作为参数传进去。")]),t._v(" "),s("p",[t._v("**注意！！**一旦将对象转换为不可扩展的，"),s("strong",[t._v("就无法再将其转换回可扩展")]),t._v("。")]),t._v(" "),s("p",[t._v("preventExtensions()只影响到对象"),s("strong",[t._v("本身")]),t._v("的可扩展性。")]),t._v(" "),s("p",[t._v("如果给一个不可扩展的对象的"),s("u",[t._v("原型")]),t._v("添加属性，这个不可扩展的对象同样会继承这些新属性。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isExtensible")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => true")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 1")]),t._v("\no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 2")]),t._v("\np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 2 继承的对象也有原型添加的属性 ")]),t._v("\n\nObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("preventExtensions")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将继承对象变为不可扩展对象")]),t._v("\np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("z "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => undefined 添加新属性失败")]),t._v("\no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在原型中添加新属性")]),t._v("\np"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("z "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 3 这个不可扩展的对象同样会继承这些新属性 preventExtensions(p)只影响本身")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("可扩展属性的目的是将对象“锁定”，以避免外界的干扰。")]),t._v(" "),s("p",[t._v("对象的可扩展性通常和属性的可配置性与可写性配合使用，ES5定义的一些函数可以更方便地设置多种属性。")]),t._v(" "),s("h4",{attrs:{id:"object-seal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-seal"}},[t._v("#")]),t._v(" Object.seal()")]),t._v(" "),s("p",[s("code",[t._v("Object.seal()")]),t._v("和"),s("code",[t._v("Object.preventExtensions()")]),t._v("类似，"),s("strong",[t._v("除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。")])]),t._v(" "),s("p",[t._v("也就是说：")]),t._v(" "),s("ul",[s("li",[t._v("不能给这个对象添加属性")]),t._v(" "),s("li",[t._v("它的已有属性也不能删除或配置")]),t._v(" "),s("li",[t._v("它已有的可写属性依然可以设置（true可以变为false）")])]),t._v(" "),s("p",[t._v("对于那些已经封闭(sealed)起来的对象是不能解封的。")]),t._v(" "),s("p",[t._v("可以使用"),s("code",[t._v("Object.isSealed()")]),t._v("来检测对象是否封闭。")]),t._v(" "),s("h4",{attrs:{id:"object-freeze"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-freeze"}},[t._v("#")]),t._v(" Object.freeze()")]),t._v(" "),s("p",[s("code",[t._v("Object.freeze()")]),t._v("将更严格地锁定对象——冻结(frozen)。")]),t._v(" "),s("p",[s("strong",[t._v("除了将对象设置为不可扩展的和将其属性设置为不可扩展之外，还可以将它的自有的所有"),s("u",[t._v("数据属性")]),t._v("设置为只读")]),t._v("。")]),t._v(" "),s("p",[t._v("如果对象的存取器属性具有setter犯法，存取器属性将不受影响，仍可以通过给属性赋值调用它们。")]),t._v(" "),s("p",[t._v("使用"),s("code",[t._v("Object.isFrozen()")]),t._v("来检测对象是否冻结。")]),t._v(" "),s("p",[s("code",[t._v("Object.seal()")]),t._v("、"),s("code",[t._v("Object.preventExtensions()")]),t._v("和"),s("code",[t._v("Object.freeze()")]),t._v("都返回传入的对象，可以通过函数嵌套的方式调用它们：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111175252.png",alt:"image-20201111175252455"}})]),t._v(" "),s("h2",{attrs:{id:"序列化对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列化对象"}},[t._v("#")]),t._v(" 序列化对象")]),t._v(" "),s("p",[s("strong",[t._v("对象序列化")]),t._v("是指将"),s("u",[t._v("对象的状态转换为字符串，也可将字符串还原为对象")]),t._v("。")]),t._v(" "),s("p",[t._v("ES5提供了内置函数"),s("code",[t._v("JSON.stringify()")]),t._v("和"),s("code",[t._v("JSON.parse()")]),t._v("用来序列化和还原JS对象。")]),t._v(" "),s("p",[t._v("JSON的语法和JS对象与数组直接量的语法非常接近：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111175413.png",alt:"image-20201111175413537"}})]),t._v(" "),s("p",[t._v("JSON的语法是JS语法的子集，但它不能表示JS里的所有值。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("支持对象、数组、字符串、无穷大数字、true、false、null，并且它们可以序列化和还原。")])]),t._v(" "),s("li",[s("p",[t._v("NaN、Infinity和-Infinity序列化的结果是null")])]),t._v(" "),s("li",[s("p",[t._v("日期对象序列化的结果是ISO格式的日期字符串，但"),s("code",[t._v("JSON.parse()")]),t._v("依然保留它们的字符串形态，而不会将它们还原为原始日期对象。")])]),t._v(" "),s("li",[s("p",[t._v("函数、RegExp、Error对象和undefined值不能序列化和还原。")])]),t._v(" "),s("li",[s("p",[t._v("JSON.stringify()只能序列化对象"),s("strong",[t._v("可枚举的自有属性")]),t._v("。")])])]),t._v(" "),s("p",[t._v("对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。")]),t._v(" "),s("p",[t._v("JSON.stringify()和JSON.parse()都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。")]),t._v(" "),s("p",[t._v("详见文档。")]),t._v(" "),s("h2",{attrs:{id:"对象方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象方法"}},[t._v("#")]),t._v(" 对象方法")]),t._v(" "),s("p",[t._v("所有JS对象都从Object.prototype继承属性（除了那些不通过原型显式创建的对象）。")]),t._v(" "),s("p",[t._v("这些继承属性主要是方法。")]),t._v(" "),s("p",[t._v("本节对定义在Object.prototype里的对象方法展开讲解，这些方法非常好用且使用广泛，但一些特定的类会重写这些方法。")]),t._v(" "),s("h3",{attrs:{id:"tostring-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tostring-方法"}},[t._v("#")]),t._v(" toString()方法")]),t._v(" "),s("p",[t._v("没有参数，返回一个表示调用这个方法的对象值的字符串。")]),t._v(" "),s("p",[t._v("在需要将对象转换为字符串的时候，JS都会调用这个方法（比如加法运算符连接字符串和对象时）")]),t._v(" "),s("p",[t._v("默认的toString()方法返回值带有的信息量很少（它在检测对象的类型时非常有用），所以很多类都带有自定义的toString().")]),t._v(" "),s("p",[t._v("例如：")]),t._v(" "),s("ul",[s("li",[t._v("数组转换为字符串时，结果是一个数组元素列表，只是每个元素都转换成了字符串")]),t._v(" "),s("li",[t._v("函数转换为字符串时，得到函数的源代码")])]),t._v(" "),s("h3",{attrs:{id:"tolocalestring-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tolocalestring-方法"}},[t._v("#")]),t._v(" toLocaleString()方法")]),t._v(" "),s("p",[t._v("除了基本的tostring方法之外，对象都包含toLocaleString()方法。")]),t._v(" "),s("p",[t._v("这个方法返回一个表示这个对象的本地化字符串。")]),t._v(" "),s("ul",[s("li",[t._v("Object中默认的toLocaleString()方法并不做任何本地化自身的操作，它仅调用toString方法并返回对应值")]),t._v(" "),s("li",[t._v("Date和Number类对toLocaleString()方法做了定制，可以用它对数字、日期和时间做本地化转换。")]),t._v(" "),s("li",[t._v("Array类的toLocaleString()和toString唯一的不同：每个数组元素都会调用toLocaleString()方法转换为字符串，而不是各自的toString()方法")])]),t._v(" "),s("h3",{attrs:{id:"tojson-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tojson-方法"}},[t._v("#")]),t._v(" toJSON()方法")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://giriawsh-bucket.oss-cn-beijing.aliyuncs.com/img/20201111181956.png",alt:"image-20201111181956187"}})]),t._v(" "),s("h3",{attrs:{id:"valueof-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#valueof-方法"}},[t._v("#")]),t._v(" valueOf()方法")]),t._v(" "),s("p",[t._v("valueOf()方法和toString()方法非常类似，但往往当JS需要"),s("strong",[t._v("将对象转换为某种原始值而非字符串的时候")]),t._v("才会调用它，尤其是转换为数字的时候。")]),t._v(" "),s("p",[t._v("如果在需要使用原始值的上下文中使用了对象，JS就会自动调用这个方法。")]),t._v(" "),s("p",[t._v("有些内置类自定义了valueOf()方法(比如Date.valueOf()).")])])}),[],!1,null,null,null);e.default=_.exports}}]);